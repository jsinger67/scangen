#![allow(clippy::manual_is_ascii_check)]

use crate::{DfaData, FindMatches, Scanner, ScannerBuilder, ScannerModeData};

const DFAS: &[DfaData] = &[
    /* 0 */
    (
        "\\r\\n|\\r|\\n",
        &[1, 2],
        &[(0, 2), (0, 0), (2, 3)],
        &[(0, (0, 2)), (0, (1, 1)), (2, (1, 1))],
    ),
    /* 1 */
    (
        "[\\s--\\r\\n]+",
        &[1],
        &[(0, 1), (1, 2)],
        &[(0, (2, 1)), (1, (2, 1))],
    ),
    /* 2 */
    (
        "(//.*(\\\\r\\\\n|\\\\r|\\\\n))",
        &[4, 5, 7],
        &[
            (0, 1),
            (1, 2),
            (2, 4),
            (4, 6),
            (0, 0),
            (6, 7),
            (7, 8),
            (0, 0),
        ],
        &[
            (0, (3, 1)),
            (1, (3, 2)),
            (2, (4, 2)),
            (2, (5, 3)),
            (3, (6, 5)),
            (3, (7, 4)),
            (5, (5, 6)),
            (6, (7, 7)),
        ],
    ),
    /* 3 */
    (
        "(/\\*[.\\r\\n]*?\\*/)",
        &[4],
        &[(0, 1), (1, 2), (2, 3), (3, 5), (0, 0)],
        &[
            (0, (3, 2)),
            (1, (3, 4)),
            (2, (8, 3)),
            (3, (8, 1)),
            (3, (9, 3)),
        ],
    ),
    /* 4 */
    (
        "[a-zA-Z_]\\w*",
        &[1],
        &[(0, 1), (1, 2)],
        &[(0, (10, 1)), (1, (11, 1))],
    ),
    /* 5 */
    (
        "\\u{5c}[\\u{22}\\u{5c}bfnt]",
        &[2],
        &[(0, 1), (1, 2), (0, 0)],
        &[(0, (12, 1)), (1, (13, 2))],
    ),
    /* 6 */
    (
        "\\u{5c}[\\s^\\n\\r]*\\r?\\n",
        &[3],
        &[(0, 1), (1, 4), (4, 5), (0, 0)],
        &[
            (0, (12, 1)),
            (1, (14, 1)),
            (1, (0, 2)),
            (1, (1, 3)),
            (2, (1, 3)),
        ],
    ),
    /* 7 */
    (
        "[^\\u{22}\\u{5c}]+",
        &[1],
        &[(0, 1), (1, 2)],
        &[(0, (15, 1)), (1, (15, 1))],
    ),
    /* 8 */
    ("\\u{22}", &[1], &[(0, 1), (0, 0)], &[(0, (16, 1))]),
    /* 9 */
    (".", &[1], &[(0, 1), (0, 0)], &[(0, (4, 1))]),
];

const MODES: &[ScannerModeData] = &[
    /* 0 */
    (
        "INITIAL",
        &[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (8, 8), (9, 9)],
        &[(8, 1)],
    ),
    /* 1 */
    (
        "STRING",
        &[
            (0, 0),
            (1, 1),
            (2, 2),
            (3, 3),
            (5, 5),
            (6, 6),
            (7, 7),
            (8, 8),
            (9, 9),
        ],
        &[(8, 0)],
    ),
];

fn matches_char_class(c: char, char_class: usize) -> bool {
    match char_class {
        /* \r */
        0 => c == '\r',
        /* \n */
        1 => c == '\n',
        /* [\s--\r\n] */
        2 => c.is_whitespace() && !(c == '\r' || c == '\n'),
        /* / */
        3 => c == '/',
        /* . */
        4 => c != '\n' && c != '\r',
        /* \\ */
        5 => c == '\\',
        /* r */
        6 => c == 'r',
        /* n */
        7 => c == 'n',
        /* \* */
        8 => c == '*',
        /* [.\r\n] */
        9 => c == '.' || c == '\r' || c == '\n',
        /* [a-zA-Z_] */
        10 => ('a'..='z').contains(&c) || ('A'..='Z').contains(&c) || c == '_',
        /* \w */
        11 => c.is_alphanumeric(),
        /* \u{5C} */
        12 => c == '\\',
        /* [\u{22}\u{5C}bfnt] */
        13 => c == '\"' || c == '\\' || c == 'b' || c == 'f' || c == 'n' || c == 't',
        /* [\s^\n\r] */
        14 => c.is_whitespace() || c == '^' || c == '\n' || c == '\r',
        /* [^\u{22}\u{5C}] */
        15 => !(c == '\"' || c == '\\'),
        /* \u{22} */
        16 => c == '\"',
        _ => false,
    }
}

pub(crate) fn create_scanner() -> Scanner {
    ScannerBuilder::new()
        .add_dfa_data(DFAS)
        .add_scanner_mode_data(MODES)
        .build()
}

pub(crate) fn create_find_iter<'r, 'h>(
    scanner: &'r mut Scanner,
    input: &'h str,
) -> FindMatches<'r, 'h> {
    scanner.find_iter(input, matches_char_class)
}
